import logging

import numpy as np
import pandas as pd
import xarray as xr

from ska_sdp_piper.piper.utils import read_dataset, read_yml
from ska_sdp_spectral_line_imaging.diagnosis.plot import (
    amp_vs_channel_plot,
    create_plot,
)
from ska_sdp_spectral_line_imaging.stages.select_vis import select_field

logger = logging.getLogger()


class SpectralLineDiagnoser:
    """
    Spectral line imaging pipeline diagnoser class.

    Attributes
    ----------
      input_path: Path
          path of pipeline run output.
      output_dir: Path
          Location where to store diagnose output.
      pipeline_args: dict
          Dictionary of cli arguments pipeline ran with.
      pipeline_config: dict
          Dictionary of pipeline configuration.
      input_ps: Xarray.Dataset
          Input processing provided to pipeline.
      residual: Xarray.Dataset
          Residual visibilities generated by the pipeline.
          Visibilities after continuum subtraction generated by the pipeline.
      model: Xarray.DataArray
          Model used in continuum subtraction stage in pipeline.
    """

    def __init__(self, input_path, output_path, channel):
        """
        Initialise the Diagnoser object
        """
        self.input_path = input_path
        self.output_dir = output_path
        self.channel = channel

        cli_yaml_path = next(input_path.glob("*.cli.yml"))
        self.pipeline_args = read_yml(cli_yaml_path)

        config_yaml_path = next(self.input_path.glob("*.config.yml"))
        self.pipeline_config = read_yml(config_yaml_path)

        self.input_ps = None
        self.residual = None
        self.model = None

        self.__read_input_data()

    def diagnose(self):
        """
        Main method that runs the diagnosis steps.
        """

        logger.info("Creating plots...")

        self.__plot_uv_distance()

        input_pol = self.input_ps.polarization.values
        residual_pol = self.pipeline_config["parameters"]["read_model"]["pols"]

        self.__plot_visibility(
            xr.where(self.input_ps.FLAG, None, self.input_ps.VISIBILITY),
            "Input Visibilities",
            "input-vis",
            input_pol,
        )

        if self.residual is not None:

            flagged_residual_vis = xr.where(
                self.input_ps.FLAG, None, self.residual.VISIBILITY
            )
            self.__plot_visibility(
                flagged_residual_vis,
                "Residual Visibilities",
                "residual-vis",
                residual_pol,
            )

            self.__export_residual_csv(flagged_residual_vis)

        logger.info("=========== DIAGNOSE COMPLETED ===========")

    def __export_residual_csv(self, residual_vis):
        averaged_vis = (
            residual_vis.sel(polarization=self.input_ps.polarization[0])
            .mean(dim=["time", "baseline_id"])
            .values
        )
        pd.DataFrame(
            {
                "channel": self.residual.frequency.values,
                "visibility": averaged_vis,
                "absolute visibility": np.abs(averaged_vis),
            }
        ).to_csv(self.output_dir / "residual.csv", index=False)

    def __plot_visibility(
        self,
        visibilities,
        plot_title_postfix,
        file_postfix,
        label,
    ):
        logger.info(f"Creating {plot_title_postfix}")
        poloarizations = self.input_ps.polarization

        amp_vs_channel_plot(
            visibilities.sel(polarization=poloarizations[0]),
            title=f"Amp Vs Channel on {plot_title_postfix}",
            path=self.output_dir
            / f"single-pol-i-amp-vs-channel-{file_postfix}.png",
            label=label[0:1],
        )

        amp_vs_channel_plot(
            visibilities,
            title=f"Amp Vs Channel on {plot_title_postfix}",
            path=self.output_dir
            / f"all-pol-amp-vs-channel-{file_postfix}.png",
            label=label,
        )

    def __plot_uv_distance(self):
        uv_distance = self.__get_uv_dist()
        polarizations = self.input_ps.polarization

        input_vis = (
            xr.where(self.input_ps.FLAG, None, self.input_ps.VISIBILITY)
            .sel(polarization=polarizations[0])
            .isel(frequency=self.channel)
        )

        create_plot(
            np.abs(uv_distance),
            np.abs(input_vis),
            xlabel="uv distance",
            ylabel="amp",
            title="Amp vs UV Distance before Continnum Subtraction",
            path=self.output_dir / "amp-vs-uv-distance-before-cont-sub.png",
            label=None,
        )

        if self.residual is not None:
            residual_vis = (
                xr.where(self.input_ps.FLAG, None, self.residual.VISIBILITY)
                .sel(polarization=polarizations[0])
                .isel(frequency=self.channel)
            )

            create_plot(
                np.abs(uv_distance),
                np.abs(residual_vis),
                xlabel="uv distance",
                ylabel="amp",
                title="Amp vs UV Distance after Continnum Subtraction",
                path=self.output_dir / "amp-vs-uv-distance-after-cont-sub.png",
                label=None,
            )

        if self.model is not None:
            model_vis = (
                xr.where(self.input_ps.FLAG, None, self.model)
                .sel(polarization=polarizations[0])
                .isel(frequency=self.channel)
            )

            create_plot(
                np.abs(uv_distance),
                np.abs(model_vis),
                xlabel="uv distance",
                ylabel="amp",
                title="Amp vs UV Distance model",
                path=self.output_dir / "amp-vs-uv-distance-model.png",
                label=None,
            )

    def __read_input_data(self):
        """
        Read
            - input processing set
            - residual
            - model data

        required for diagnosis.
        """

        pipeline_parameter = self.pipeline_config["parameters"]
        select_vis_config = pipeline_parameter["select_vis"]
        pipeline_run_config = self.pipeline_config["pipeline"]
        input_ps = read_dataset(self.pipeline_args["input"])
        logger.info("Reading input visibility")
        self.input_ps = select_field.stage_definition(
            None,
            **select_vis_config,
            _input_data_=input_ps,
        )["ps"]

        if pipeline_run_config.get("export_model"):
            logger.info("Reading model data")
            ps_out = pipeline_parameter["export_model"]["psout_name"]
            self.model = xr.open_zarr(self.input_path / ps_out)[
                "VISIBILITY_MODEL"
            ]
        else:
            logger.info("Export model stage not run.")

        if pipeline_run_config.get("export_residual"):
            logger.info("Reading residual data")
            ps_out = pipeline_parameter["export_residual"]["psout_name"]
            self.residual = xr.open_zarr(self.input_path / ps_out)
        else:
            logger.info("Export residual stage not run.")

    def __get_uv_dist(self):
        vec_cal_uv_distance = np.vectorize(
            lambda uvw: (uvw[0] ** 2 + uvw[1] ** 2) ** 0.5, signature="(n)->()"
        )
        uv_distance = vec_cal_uv_distance(self.input_ps.UVW)
        return uv_distance
